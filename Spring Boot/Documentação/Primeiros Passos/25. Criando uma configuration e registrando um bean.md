
## 1. Classe `TesteFabricaController`

```Java
package curso.arquiteturaspring.montadora.api;  

@RestController 
public class TesteFabricaController {
```

Essa classe é um **Controller Spring**, responsável por expor um ponto de entrada da aplicação (API) para testar a “fábrica” de carros. Ela não contém regras de negócio complexas; seu papel é **orquestrar objetos do domínio**.

### Injeção de dependência do `Motor`

```Java
@Autowired private Motor motor;
```

Aqui ocorre **injeção de dependência via campo**:
- O Spring procura um **bean do tipo `Motor`** no contexto
- Injeta automaticamente esse objeto nessa variável
- O controller não cria o motor manualmente

Esse motor vem da classe `MontadoraConfiguration`.

### Método `ligarCarro`

```Java
public CarroStatus ligarCarro(@RequestBody Chave chave){
     var carro = new HondaHRV(motor);     
     return carro.darIgnicao(chave); 
}
```


- `@RequestBody Chave chave`  
    O Spring converte o JSON recebido na requisição em um objeto `Chave`.

- `var carro = new HondaHRV(motor);`  
    Um carro específico (`HondaHRV`) é criado, recebendo o **motor injetado pelo Spring**.

- `carro.darIgnicao(chave)`  
    A lógica de negócio não fica no controller, mas no **domínio (`Carro`)**.

Esse método retorna um `CarroStatus`, que representa o resultado da tentativa de ligar o carro.

## 2. Classe `CarroStatus`

```Java
package curso.arquiteturaspring.montadora;

public record CarroStatus(String mensagem) { 
}
```

### O que é um `record`

`record` é um recurso do Java para criar **classes imutáveis de transporte de dados** (DTOs) de forma simples.

Esse record:
- possui um único campo `mensagem`
- já gera automaticamente:
    - construtor
    - getter
    - `toString`
    - `equals` e `hashCode`

Ele é usado para **retornar informações simples ao cliente**, sem lógica de negócio.

## 3. Classe `MontadoraConfiguration`

```Java
@Configuration 
public class MontadoraConfiguration {
```

Essa classe é uma **classe de configuração do Spring**. Ela define **beans manualmente**, em vez de usar `@Component`.

### Bean `Motor`

```Java
@Bean public Motor motor(){
     var motor = new Motor();     
     motor.setCavalos(120);     
     motor.setCilindros(4);     
     motor.setModelo("XPTO-0");     
     motor.setLitragem(2.0);     
     motor.setTipo(TipoMotor.ASPIRADO);     
     return motor; }
```

Aqui o Spring:
1. Executa esse método na inicialização
2. Cria um objeto `Motor`
3. Registra esse objeto no **Application Context**
4. Disponibiliza esse motor para injeção (`@Autowired`)

Esse motor passa a ser:
- único (singleton, por padrão)
- reutilizado sempre que necessário

Esse é o **conceito de fábrica controlada pelo Spring**.

## 4. Alteração na classe `Carro`

```Java
public CarroStatus darIgnicao(Chave chave) {

     if(chave.getMontadora() != this.montadora){         
     return new CarroStatus("Não é possível ligar o carro com esta chave");     
     }
          
     return new CarroStatus("Carro ligado. Rodando com o motor "+motor); }
```

### O que esse método faz

Esse método implementa uma **regra de negócio do domínio**:

- Um carro **só pode ser ligado com uma chave da mesma montadora**
- A validação compara:
    - `chave.getMontadora()`
    - `this.montadora`

Como `Montadora` é um `enum`, a comparação com `!=` é segura.

### Resultado do método
- Se a chave não for compatível → retorna erro
- Se for compatível → retorna sucesso com dados do motor

A decisão **não está no controller**, mas no domínio, o que é uma boa prática de arquitetura.

## 5. Alteração na classe `Motor`

```Java
@Override 
public String toString() {
     return "Motor{" +             
     "modelo='" + modelo + '\'' +             
     ", cavalos=" + cavalos +             
     ", cilindros=" + cilindros +             
     ", litragem=" + litragem +             
     ", tipo=" + tipo +             
     '}'; 
}
```

### Para que serve esse `toString`

Esse método define **como o motor será representado em texto**.
Ele é usado automaticamente quando o motor é concatenado com uma `String`, por exemplo:

`"Rodando com o motor " + motor`

Sem esse override, o Java exibiria algo como:
`Motor@3f2a3d`

Com o override, o retorno fica legível e informativo.