
## 1. ProdutoRepository
### Declaração do pacote
A instrução `package` define o **namespace** da interface e indica que ela pertence à camada de **repositório**, responsável pelo acesso a dados e comunicação com o banco de dados.

```Java
package io.github.cursodsousa.produtosapi.repository;
```

### Importação da entidade

Essa importação permite que o repositório saiba **qual entidade JPA ele irá gerenciar**. Nesse caso, a entidade é a classe `Produto`.

```Java
import io.github.cursodsousa.produtosapi.model.Produto;
```

### Importação do `JpaRepository`

A interface `JpaRepository` faz parte do **Spring Data JPA** e fornece uma implementação pronta de operações CRUD (Create, Read, Update, Delete), além de paginação e ordenação, sem que seja necessário escrever SQL ou implementar métodos manualmente.

```Java
import org.springframework.data.jpa.repository.JpaRepository;
```

### Declaração da interface

A palavra-chave `public` torna a interface acessível a outras camadas da aplicação. A palavra-chave `interface` define um contrato que será implementado automaticamente pelo Spring em tempo de execução.

```Java
public interface ProdutoRepository extends JpaRepository<Produto, String> { 
}
```

### Uso de `extends JpaRepository`

Ao estender `JpaRepository`, a interface `ProdutoRepository` herda automaticamente uma série de métodos prontos para acesso ao banco de dados. Não é necessário criar nenhuma implementação concreta dessa interface.

O `JpaRepository` utiliza **generics**, que nesse caso são:
- `Produto`: a entidade que será persistida
- `String`: o tipo do identificador (`@Id`) da entidade

```Java
extends JpaRepository<Produto, String>
```

Isso informa ao Spring:
- Qual tabela será manipulada (via entidade `Produto`)
- Qual o tipo da chave primária (`String`)

## 2. ProdutoRepository

### Atributo `ProdutoRepository` no controller (adição)

Foi criado um atributo privado do tipo `ProdutoRepository`. Esse atributo será usado para chamar métodos de persistência, como `save`.

O uso de `private` mantém o encapsulamento, e o controller passa a depender explicitamente do repositório.

**Código adicionado:**

```Java
private ProdutoRepository produtoRepository;
```

### Construtor com injeção de dependência (adição)

Foi adicionado um construtor que recebe o `ProdutoRepository` como parâmetro. Essa é a forma **recomendada pelo Spring** para injeção de dependência (constructor injection).

O Spring detecta automaticamente o repositório, cria a implementação e injeta no controller.

**Código adicionado:**

```Java
public ProdutoController(ProdutoRepository produtoRepository) { 
    this.produtoRepository = produtoRepository; 
}
```

Efeito prático:

- O controller passa a ter acesso ao banco
- Não é necessário usar `@Autowired`
- O código fica mais testável e explícito

### Geração de ID com `UUID` (adição)

Foi adicionada a geração de um identificador único para o produto. O método `UUID.randomUUID()` cria um UUID, que é convertido para `String` para compatibilidade com o tipo do campo `id`.

O uso de `var` permite inferência de tipo, mantendo o código mais limpo.
**Código adicionado:**

```Java
var id = UUID.randomUUID().toString();
```

### Atribuição do ID ao produto (adição)

Após gerar o UUID, o valor é atribuído ao objeto `Produto`. Isso é essencial porque:
- O campo `id` é a chave primária (`@Id`)
- O JPA exige que a entidade tenha um identificador antes de persistir

**Código adicionado:**

```Java
produto.setId(id);
```

### Persistência do produto no banco (adição principal)

Aqui está a mudança mais importante do controller. O método `save` do `ProdutoRepository` é chamado para **persistir o objeto no banco de dados**.

A partir desse ponto:
- O produto deixa de ser apenas um objeto em memória
- Um registro é criado na tabela `produto` do H2

**Código adicionado:**
```Java
produtoRepository.save(produto);
```

### Retorno do produto persistido

O método continua retornando o objeto `Produto`, mas agora ele:
- Possui um `id`
- Já foi salvo no banco
- Representa um estado persistente da aplicação
### Resumo conceitual das mudanças

Antes:
- O controller apenas recebia e devolvia o JSON
- Nenhum dado era salvo no banco
- O H2 Console mostrava a tabela vazia

Depois:
- O controller injeta um repositório
- Gera um ID único
- Persiste o produto no banco
- Retorna o objeto salvo
- Os dados passam a aparecer no H2 Console

Essa evolução marca a transição de uma **API de teste** para uma **API com persistência real**, conectando corretamente:  
**Postman → Controller → Repository → Banco de Dados (H2)**