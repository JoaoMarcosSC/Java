
## Visão geral da classe `AutorRepositoryTest`

Essa classe é um **teste de integração** do repositório `AutorRepository`.  
Ela valida se o Spring Boot, o JPA/Hibernate e o banco de dados estão funcionando **de forma integrada**, sem mocks.

## Anotação `@SpringBootTest`

### O que é
`@SpringBootTest` indica que o **contexto completo do Spring Boot** será carregado durante o teste.

Isso significa que:
- Application Context é inicializado
- Beans reais são criados
- Datasource real é usado
- Hibernate executa SQL de verdade

É um **teste de integração**, não um teste unitário.

### Trecho do código

```Java
@SpringBootTest public class AutorRepositoryTest {
```


## Injeção do repositório com `@Autowired`

### O que é

O Spring injeta automaticamente a implementação gerada do `AutorRepository`.
- Não existe `new`
- O repositório é um bean gerenciado
- Já vem configurado com EntityManager e transações

### Trecho do código

```Java
@Autowired AutorRepository repository;
```

## Anotação `@Test`

### O que é

Marca um método como **caso de teste** para o JUnit 5.
- Cada método anotado é executado separadamente
- A falha de um teste não impede a execução dos outros

### Trecho do código

```Java
@Test public void atualizarTest(){
```

### Criação de um UUID fixo

```Java
var id = UUID.fromString("fa4b816a-2290-4655-8d86-8d945d24b4f6");
```

Aqui é definido manualmente:
- O ID de um autor que **já existe no banco**
- Necessário para testar atualização

## Busca por ID com `findById`

### O que retorna

```Java
Optional<Autor> possivelAutor = repository.findById(id);
```

O método `findById` retorna um `Optional<Autor>` porque:
- O registro pode existir
- Ou pode não existir

Isso evita `NullPointerException`.

## Uso do `Optional.isPresent()`

```Java
if(possivelAutor.isPresent()){
```

Verifica se o autor foi encontrado antes de acessar o objeto.
Esse é o **uso correto de Optional**.

## Atualizando o registro encontrado

```Java
Autor autorEncontrado = possivelAutor.get(); autorEncontrado.setDataNascimento(LocalDate.of(1960, 1, 30)); repository.save(autorEncontrado);
```

O que acontece aqui:
- O autor já possui ID
- O `save` detecta isso
- Executa um `UPDATE` ao invés de `INSERT`
- Apenas o campo alterado é atualizado